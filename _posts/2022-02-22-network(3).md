---
title: "TLS 1.2 vs 1.3"
categories:
  - Network
date: 2022-02-22 19:00:25 +0900
tags:
  - TLS
  - Network
---
# TLS 1.2

* TLS encrpyt all your application data in packet. Here is a whole process of how server/client exhange their keys and how they encrypt packets.

Before TLS, Server create **CSR**
> CSR contains Country Name, State or Province Name, Locality Name, Organization, Organization Unit, Common Name
{: .prompt-info}
> ![a](../../assets/p/3/CA.png)

And next, Server send CSR to CA(Certificate Authority)

> 1. A -> Certificate Authority(Google, Amazon, etc.)
  CSR(Certificate Signing Request) : A's pub_key + identity + sign(A's priv_key,(A's pub_key, identity))
> 2. Certificate Authority -> A
  check A's sign and sign with Certificate Authority's priv_key
> 3. A's Certificate : CSR + sign(Certificate Authority's priv_key, content1)
> 4. A -> B
  with A's Certificate
> 5. B
  verify A's Certificate with Certificate Authority's pub_key

  Here, Man in the Middle can not replace A's pub_key with their pub_key.   
  Now Server has `certificate`! And from now, they can open port HTTPS(443).   
  **To exchange server/client encryption key**, TLS do **handshakes**. It is little bit different  by its version. First TLS 1.2 version do their handshake as below.   

## Initial Handshake(2-RTT)
1. Client Hello
  *	Client send `Client Hello` to Server
  *	`Client Hello` : [Version, Nonce, Session ID, Cipher Suites, Compression Methods, etc.]

2. Server Hello
  *	Server send `Server Hello` to Client
  *	`Server Hello` : [Version, Nonce, Session ID, Cipher Suites, Compression Methods, etc.]

3. Certificate
  *	Server also send `certificate` to Client
  *	If Server need Client's certificate, they reqeust.
  *	Client verify Server's certificate with CA's pubkey and etc.

4. Server Key Exchange
  * Server make ECDHE key pairs and send public key to Client with message type `Server Key Exchange`
  * This key will be used to make ECDHE shared secret(symetric key).

5. Certificate Request(optional)
  * Server send `Certificate Request` to Client(if Server wants it)

6. Server Hello Done
  * Server inform Client that my handshake process is done!

7. Certificate(optional)
  *	Client send `certificate` to Server
  *	Server verify Client's certificate
  
8. Client Key Exchange
  * Cient make ECDHE key pairs and send public key to Server with message type `Client Key Exchange`

> Encryption Keys Calculation
*	서버와 클라이언트는 상대방으로부터 받은 public 키를 이용해서 PreMasterSecret라고 부르는 ECDHE shared secret를 생성한다. 
*	PreMasterSecret을 키로 쌍방의 Nonce값을 HMAC 연산한 결과를 이용해서 MasterSecret를 생성한다. 
*	MasterSecret 값을 가지고 다음 용도로 사용한다. 
*	클라이언트/서버의 MAC 키
*	클라이언트/서버의 대칭 암호 키
*	클라이언트/서버의 CBC 암호화 용 IV(Initial Vector)값 

9. Certificate Verify
  *	Client hash all handshake messages and sign, send to Server.
  *	Server verify sign and compare hash that is same as mine.

10. Change Cipher Spec
  * Client inform Server that from now, i will send all messages with encrpyted data.
  
11.  Finished(Encrypted Handshake Message)
  * Client hash all handshake messages and **encrypt** with shared-key, send to Server.

12. Change Cipher Spec
  * Server inform Client that from now, i will send all messages with encrpyted data.

13. Finished(Encrypted Handshake Message)
    * Server hash all handshake messages and **encrypt** with shared-key, send to Client.



# TLS 1.3


1.	Add 0-RTT, 1-RTT for handshake.
2.	정적인 RSA와 디피-헬먼 암호화 스위트(Diffie-Hellman Cipher Suite) 제거. 즉, forward secrecy를 제공해주는 DHE, ECDHE만 사용하여 key 교환.
3.	키 교환과 암호화 방식을 암호화 스위트(Cipher Suite)방식이 아니라, 개별적으로 결정. 즉, 원하는 키 교환 방식 및 암호화 방식 선택 가능. 물론 범주내에서.

## Initial Handshake(1-RTT)
1. Client Hello
  *	Same with TLS 1.2, but Client make ECDHE key pairs and send public key to Server with message type `Client Hello`  

2. Server Hello
  *	ServerHello + Server Key Exchange + Certificate Request + Certificate + Finished = encrypt(TLS1.3 `Server Hello`)"

3. Finished(Certificate + CertificateVerify + Finished=encrypt(TLS1.3 ClientHello)+ “Application Data” )
  * Certificate + CertificateVerify + Finished = encrypt(TLS1.3 ClientHello)
  * Here, Client can send add Application data(which is supported from TLS 1.3 **1-RTT**)

# TCP+HTTPS+DNS RTT Comparison(TLS 1.2 vs TLS 1.3)
To summary, Here is table for comparing RTT with TLS 1.2 and TLS 1.3.


| is initial or resumption? | TLS 1.2                  | TLS 1.3     | TLS 1.3 + 0-RTT |
| ------------------------- | ------------------------ | ----------- | --------------- |
| New connection            | 4 RTT(TCP:1,TLS:3)       | 3 RTT + DNS | 3 RTT + DNS     |
| Resume connection         | 3 RTT + DNS(TCP:1,TLS:2) | 3 RTT + DNS | 2 RTT + DNS     |

